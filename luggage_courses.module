<?php
/**
 * @file
 * Code for the luggage_courses feature.
 */

include_once 'luggage_courses.features.inc';

/**
 * Token key used for courses.
 */
define('LUGGAGE_COURSES_TOKEN_TYPE', 'luggage_courses');

/**
 * Implements hook_update_projects_alter().
 */
function luggage_courses_update_projects_alter(&$projects) {
  // Hide a site-specific module from the list.
  unset($projects['luggage_courses']);
}

/**
 * Implements hook_token_info()
 */
function luggage_courses_token_info() {
  return array(
    'types' => array(
      LUGGAGE_COURSES_TOKEN_TYPE => array(
        'name' => t('Course tokens'),
        'description' => t('Tokens for course content.'),
      ),
    ),
    'tokens' => array(
      LUGGAGE_COURSES_TOKEN_TYPE => array(
        'section_course_title' => array(
          'name' => t('Section\'s course title'),
          'description' => t('Renders the title of the course that a section is attached to'),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_tokens().
 */
function luggage_courses_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == LUGGAGE_COURSES_TOKEN_TYPE) {
    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'section_course_title':
          $node = $data['node'];
          $query = new EntityFieldQuery();
          $query->entityCondition('entity_type', 'node')
            ->entityCondition('bundle', 'course')
            ->fieldCondition('field_course_section', 'target_id', $node->nid);
          $result = $query->execute();
          if (!empty($result)) {
            $nid = key($result['node']);
            $node = node_load($nid);
            $replacements[$original] = check_plain($node->title);
          }
          break;
      }
    }
  }

  return $replacements;
}

